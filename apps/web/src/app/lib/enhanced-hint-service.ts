/**
 * Enhanced Hint Service (Feature Branch)
 * 
 * Intelligent hint generation that leverages available resources:
 * - If Textbook connected: Include relevant textbook units in context
 * - If LLM connected: Generate personalized hints with full context
 * - If neither: Fall back to SQL-Engage CSV hints only
 * 
 * Design inspired by:
 * - PELICAN: Personalized Education via LLM (adaptive tutoring frameworks)
 * - LPITutor: LLM-based personalized intelligent tutoring
 * - Theory of Adaptive Scaffolding for LLM-Based pedagogical agents
 */

import type { 
  InteractionEvent, 
  InstructionalUnit,
  SqlEngageRecord 
} from '../types';
import { 
  GuidanceRung, 
  RUNG_DEFINITIONS,
  EscalationTrigger 
} from './guidance-ladder';
import {
  getProgressiveSqlEngageHintText,
  getSqlEngageRowsBySubtype,
  canonicalizeSqlEngageSubtype
} from '../data/sql-engage';
import { storage } from './storage';
import { buildRetrievalBundle, RetrievalBundle } from './retrieval-bundle';
import { getProblemById } from '../data/problems';

/**
 * Available resource types for hint generation
 */
export type AvailableResources = {
  /** SQL-Engage CSV dataset is always available */
  sqlEngage: boolean;
  /** Textbook has saved units for this learner */
  textbook: boolean;
  /** LLM service is reachable */
  llm: boolean;
  /** PDF index is loaded */
  pdfIndex: boolean;
};

/**
 * Enhanced hint with metadata about sources used
 */
export type EnhancedHint = {
  /** The hint content */
  content: string;
  /** Which rung this hint belongs to */
  rung: GuidanceRung;
  /** Sources that contributed to this hint */
  sources: {
    sqlEngage: boolean;
    textbook: boolean;
    llm: boolean;
    pdfPassages: boolean;
  };
  /** Concept IDs referenced */
  conceptIds: string[];
  /** Source reference IDs (for rung 2+) */
  sourceRefIds?: string[];
  /** Textbook units referenced (if available) */
  textbookUnits?: InstructionalUnit[];
  /** Whether this was generated by LLM */
  llmGenerated: boolean;
  /** Confidence score (0-1) based on source richness */
  confidence: number;
};

/**
 * Options for hint generation
 */
export type HintGenerationOptions = {
  /** Learner ID */
  learnerId: string;
  /** Problem ID */
  problemId: string;
  /** Session ID (optional) */
  sessionId?: string;
  /** Current error subtype */
  errorSubtypeId?: string;
  /** Target rung level */
  rung: GuidanceRung;
  /** Recent interactions for context */
  recentInteractions: InteractionEvent[];
  /** Whether to force LLM generation even if available */
  forceLLM?: boolean;
};

/**
 * Check which resources are available for hint generation
 */
export function checkAvailableResources(learnerId: string): AvailableResources {
  // SQL-Engage is always available (bundled CSV)
  const sqlEngage = true;
  
  // Check if learner has textbook content
  const textbookUnits = storage.getTextbook(learnerId);
  const textbook = textbookUnits.length > 0;
  
  // Check LLM availability (Ollama or other provider)
  const llm = checkLLMAvailability();
  
  // Check PDF index
  const pdfIndex = checkPDFIndexAvailability();
  
  return { sqlEngage, textbook, llm, pdfIndex };
}

/**
 * Check if LLM service is available
 */
function checkLLMAvailability(): boolean {
  // Check if Ollama URL is configured and reachable
  const ollamaUrl = import.meta.env.VITE_OLLAMA_URL || 'http://localhost:11434';
  // Note: Actual check would require an async ping, this is a sync check
  // The service will handle failures gracefully
  return Boolean(ollamaUrl);
}

/**
 * Check if PDF index is available
 */
function checkPDFIndexAvailability(): boolean {
  const pdfIndex = storage.getPdfIndex();
  return pdfIndex !== null && pdfIndex.chunkCount > 0;
}

/**
 * Find relevant textbook units for the current error context
 */
function findRelevantTextbookUnits(
  learnerId: string,
  errorSubtypeId: string,
  conceptIds: string[]
): InstructionalUnit[] {
  const allUnits = storage.getTextbook(learnerId);
  
  if (allUnits.length === 0) return [];
  
  // Score each unit by relevance
  const scored = allUnits.map(unit => {
    let score = 0;
    
    // Match by concept ID
    if (unit.conceptId && conceptIds.includes(unit.conceptId)) {
      score += 3;
    }
    
    // Match by content similarity (simple keyword matching)
    const content = unit.content.toLowerCase();
    const errorKeywords = errorSubtypeId.toLowerCase().split(/[-_]/);
    for (const keyword of errorKeywords) {
      if (keyword.length > 3 && content.includes(keyword)) {
        score += 1;
      }
    }
    
    // Boost for recent units (within last 7 days)
    const ageMs = Date.now() - (unit.addedTimestamp || 0);
    if (ageMs < 7 * 24 * 60 * 60 * 1000) {
      score += 0.5;
    }
    
    return { unit, score };
  });
  
  // Sort by score and return top 3
  scored.sort((a, b) => b.score - a.score);
  return scored
    .filter(s => s.score > 0)
    .slice(0, 3)
    .map(s => s.unit);
}

/**
 * Generate fallback hint from SQL-Engage CSV only
 */
function generateSqlEngageFallbackHint(
  errorSubtypeId: string,
  rung: GuidanceRung
): EnhancedHint {
  const canonicalSubtype = canonicalizeSqlEngageSubtype(errorSubtypeId);
  const records = getSqlEngageRowsBySubtype(canonicalSubtype);
  
  // Get hint text based on rung
  let content: string;
  
  if (records.length > 0) {
    // Use progressive hint from SQL-Engage
    const record = records[0];
    content = getProgressiveSqlEngageHintText(record, rung);
  } else {
    // Ultimate fallback: generic hint based on rung
    content = getGenericFallbackHint(rung, errorSubtypeId);
  }
  
  return {
    content,
    rung,
    sources: {
      sqlEngage: true,
      textbook: false,
      llm: false,
      pdfPassages: false
    },
    conceptIds: [],
    llmGenerated: false,
    confidence: 0.5 // Medium confidence for CSV-only hints
  };
}

/**
 * Get generic fallback hint when no SQL-Engage record exists
 */
function getGenericFallbackHint(rung: GuidanceRung, errorSubtypeId: string): string {
  const definitions = RUNG_DEFINITIONS[rung];
  
  if (rung === 1) {
    return `Check your ${errorSubtypeId.replace(/-/g, ' ')}. ${definitions.examples[0] || 'Review the syntax carefully.'}`;
  }
  
  if (rung === 2) {
    return `This error relates to ${errorSubtypeId.replace(/-/g, ' ')}. ` +
           `Make sure you understand the concept before proceeding. ` +
           `Refer to your course materials for examples.`;
  }
  
  // Rung 3
  return `## Summary\n\n` +
         `This problem involves ${errorSubtypeId.replace(/-/g, ' ')}.\n\n` +
         `## Common Mistakes\n\n` +
         `- Syntax errors\n` +
         `- Missing clauses\n\n` +
         `## Key Takeaway\n\n` +
         `Practice makes perfect!`;
}

/**
 * Build enhanced retrieval bundle with textbook content
 */
function buildEnhancedRetrievalBundle(
  options: HintGenerationOptions,
  resources: AvailableResources
): RetrievalBundle & { textbookUnits?: InstructionalUnit[] } {
  const { learnerId, problemId, errorSubtypeId, recentInteractions } = options;
  
  // Start with standard retrieval bundle
  const problem = getProblemById(problemId);
  const baseBundle = buildRetrievalBundle({
    learnerId,
    problem,
    interactions: recentInteractions,
    lastErrorSubtypeId: errorSubtypeId
  });
  
  // Add textbook units if available
  let textbookUnits: InstructionalUnit[] | undefined;
  if (resources.textbook && errorSubtypeId) {
    const conceptIds = baseBundle.conceptCandidates.map(c => c.id);
    textbookUnits = findRelevantTextbookUnits(learnerId, errorSubtypeId, conceptIds);
  }
  
  return {
    ...baseBundle,
    textbookUnits
  };
}

/**
 * Generate hint using available resources
 * 
 * DECISION MATRIX:
 * - LLM available + Textbook available: Full LLM with textbook context
 * - LLM available + No Textbook: LLM with SQL-Engage + PDF only
 * - No LLM + Textbook available: Enhanced SQL-Engage with textbook references
 * - No LLM + No Textbook: SQL-Engage CSV only (fallback)
 */
export async function generateEnhancedHint(
  options: HintGenerationOptions
): Promise<EnhancedHint> {
  const { learnerId, rung, errorSubtypeId, forceLLM } = options;
  
  // Check available resources
  const resources = checkAvailableResources(learnerId);
  
  // Build enhanced retrieval bundle
  const retrievalBundle = buildEnhancedRetrievalBundle(options, resources);
  
  // Decision: Can we use LLM?
  const canUseLLM = resources.llm && (forceLLM || rung >= 2);
  
  // Decision: Do we have textbook content?
  const hasTextbookContent = retrievalBundle.textbookUnits && 
                             retrievalBundle.textbookUnits.length > 0;
  
  // CASE 1: LLM available → Generate AI-powered hint
  if (canUseLLM) {
    return generateLLMEnhancedHint(options, retrievalBundle, resources);
  }
  
  // CASE 2: No LLM but Textbook available → Enhanced SQL-Engage with textbook refs
  if (hasTextbookContent && errorSubtypeId) {
    return generateTextbookEnhancedHint(options, retrievalBundle, resources);
  }
  
  // CASE 3: Neither LLM nor Textbook → SQL-Engage CSV fallback
  if (errorSubtypeId) {
    return generateSqlEngageFallbackHint(errorSubtypeId, rung);
  }
  
  // Ultimate fallback
  return {
    content: 'Review your SQL syntax and try again.',
    rung,
    sources: {
      sqlEngage: false,
      textbook: false,
      llm: false,
      pdfPassages: false
    },
    conceptIds: [],
    llmGenerated: false,
    confidence: 0.3
  };
}

/**
 * Generate LLM-enhanced hint with full context
 */
async function generateLLMEnhancedHint(
  options: HintGenerationOptions,
  retrievalBundle: RetrievalBundle & { textbookUnits?: InstructionalUnit[] },
  resources: AvailableResources
): Promise<EnhancedHint> {
  const { rung, errorSubtypeId } = options;
  
  // Import LLM contracts dynamically to avoid circular dependencies
  const { generateGuidanceFromLLM, validateLLMOutput } = await import('./llm-contracts');
  
  try {
    // Generate using LLM with full retrieval bundle
    const llmOutput = await generateGuidanceFromLLM(rung, retrievalBundle);
    
    // Validate output
    const validation = validateLLMOutput(llmOutput.content, rung, retrievalBundle);
    
    if (validation.valid) {
      return {
        content: llmOutput.content,
        rung,
        sources: {
          sqlEngage: resources.sqlEngage,
          textbook: Boolean(retrievalBundle.textbookUnits?.length),
          llm: true,
          pdfPassages: resources.pdfIndex
        },
        conceptIds: llmOutput.conceptIds || [],
        sourceRefIds: llmOutput.sourceRefIds,
        textbookUnits: retrievalBundle.textbookUnits,
        llmGenerated: true,
        confidence: 0.9 // High confidence for LLM-generated
      };
    }
    
    // Validation failed → Fall back to SQL-Engage
    console.warn('[EnhancedHint] LLM validation failed, using fallback:', validation.errors);
    
  } catch (error) {
    console.warn('[EnhancedHint] LLM generation failed:', error);
  }
  
  // Fallback to SQL-Engage if LLM fails
  if (errorSubtypeId) {
    return generateSqlEngageFallbackHint(errorSubtypeId, rung);
  }
  
  throw new Error('Failed to generate hint with all available methods');
}

/**
 * Generate hint enhanced with textbook references (no LLM)
 */
function generateTextbookEnhancedHint(
  options: HintGenerationOptions,
  retrievalBundle: RetrievalBundle & { textbookUnits?: InstructionalUnit[] },
  resources: AvailableResources
): EnhancedHint {
  const { rung, errorSubtypeId } = options;
  const { textbookUnits = [] } = retrievalBundle;
  
  if (!errorSubtypeId) {
    throw new Error('Cannot generate hint without errorSubtypeId');
  }
  
  // Get base hint from SQL-Engage
  const baseHint = generateSqlEngageFallbackHint(errorSubtypeId, rung);
  
  // Enhance with textbook references
  let enhancedContent = baseHint.content;
  
  if (textbookUnits.length > 0 && rung >= 2) {
    // Add "See also" references to relevant textbook units
    const references = textbookUnits
      .slice(0, 2)
      .map(unit => `• "${unit.title}" (in your Textbook)`)
      .join('\n');
    
    enhancedContent += `\n\n**Related from your Textbook:**\n${references}`;
  }
  
  return {
    ...baseHint,
    content: enhancedContent,
    sources: {
      ...baseHint.sources,
      textbook: true
    },
    textbookUnits,
    confidence: 0.7 // Higher confidence with textbook refs
  };
}

/**
 * Get hint generation strategy description for UI
 */
export function getHintStrategyDescription(resources: AvailableResources): string {
  if (resources.llm && resources.textbook) {
    return 'AI-powered hints with your Textbook and course materials';
  }
  if (resources.llm) {
    return 'AI-powered hints with course materials';
  }
  if (resources.textbook) {
    return 'Hints from SQL-Engage dataset + your Textbook references';
  }
  return 'Hints from SQL-Engage dataset';
}

/**
 * Preload hint for upcoming error subtype (predictive loading)
 */
export async function preloadHintContext(
  learnerId: string,
  errorSubtypeId: string
): Promise<void> {
  const resources = checkAvailableResources(learnerId);
  
  // Pre-fetch relevant textbook units
  if (resources.textbook) {
    findRelevantTextbookUnits(learnerId, errorSubtypeId, []);
  }
  
  // Could also preload PDF passages here
}

// Export version for tracking
export const ENHANCED_HINT_SERVICE_VERSION = 'enhanced-hint-v1.0.0';
