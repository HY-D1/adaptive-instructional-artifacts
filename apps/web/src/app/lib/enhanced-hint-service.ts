/**
 * Enhanced Hint Service (Feature Branch)
 * 
 * Intelligent hint generation that leverages available resources:
 * - If Textbook connected: Include relevant textbook units in context
 * - If LLM connected: Generate personalized hints with full context
 * - If neither: Fall back to SQL-Engage CSV hints only
 * 
 * Design inspired by:
 * - PELICAN: Personalized Education via LLM (adaptive tutoring frameworks)
 * - LPITutor: LLM-based personalized intelligent tutoring
 * - Theory of Adaptive Scaffolding for LLM-Based pedagogical agents
 */

import type { 
  InteractionEvent, 
  InstructionalUnit,
  SqlEngageRecord,
  SQLProblem,
  RetrievedChunkInfo
} from '../types';
import { 
  GuidanceRung, 
  RUNG_DEFINITIONS,
  EscalationTrigger 
} from './guidance-ladder';
import {
  getProgressiveSqlEngageHintText,
  getSqlEngageRowsBySubtype,
  canonicalizeSqlEngageSubtype
} from '../data/sql-engage';
import { storage } from './storage';
import { createEventId } from './event-id';
import { buildRetrievalBundle, RetrievalBundle } from './retrieval-bundle';
import { getProblemById } from '../data/problems';

/**
 * Available resource types for hint generation
 */
export type AvailableResources = {
  /** SQL-Engage CSV dataset is always available */
  sqlEngage: boolean;
  /** Textbook has saved units for this learner */
  textbook: boolean;
  /** LLM service is reachable */
  llm: boolean;
  /** PDF index is loaded */
  pdfIndex: boolean;
};

/**
 * Enhanced hint with metadata about sources used
 */
export type EnhancedHint = {
  /** The hint content */
  content: string;
  /** Which rung this hint belongs to */
  rung: GuidanceRung;
  /** Sources that contributed to this hint */
  sources: {
    sqlEngage: boolean;
    textbook: boolean;
    llm: boolean;
    pdfPassages: boolean;
  };
  /** Concept IDs referenced */
  conceptIds: string[];
  /** Source reference IDs (for rung 2+) */
  sourceRefIds?: string[];
  /** Textbook units referenced (if available) */
  textbookUnits?: InstructionalUnit[];
  /** Whether this was generated by LLM */
  llmGenerated: boolean;
  /** Confidence score (0-1) based on source richness */
  confidence: number;
  /** Whether LLM was requested but failed (for UI feedback) */
  llmFailed?: boolean;
  /** Error message if LLM failed */
  llmErrorMessage?: string;
};

/**
 * Options for hint generation
 */
export type HintGenerationOptions = {
  /** Learner ID */
  learnerId: string;
  /** Problem ID */
  problemId: string;
  /** Session ID (optional) */
  sessionId?: string;
  /** Current error subtype */
  errorSubtypeId?: string;
  /** Target rung level */
  rung: GuidanceRung;
  /** Recent interactions for context */
  recentInteractions: InteractionEvent[];
  /** Whether to force LLM generation even if available */
  forceLLM?: boolean;
};

/**
 * Context for adaptive hint generation
 * Passed to generateAdaptiveHint for creating pedagogically progressive hints
 */
export type AdaptiveHintContext = {
  /** Current rung level (1, 2, or 3) */
  rung: 1 | 2 | 3;
  /** Error subtype identifier */
  errorSubtype: string;
  /** Current problem information */
  problem: SQLProblem;
  /** Array of hints already given to the learner */
  previousHints: string[];
  /** Relevant textbook content */
  textbookUnits: InstructionalUnit[];
  /** Relevant PDF passages */
  pdfPassages: RetrievedChunkInfo[];
  /** SQL-Engage records for this error subtype */
  sqlEngageRecords: SqlEngageRecord[];
};

/**
 * Parsed LLM output for adaptive hints
 */
type AdaptiveHintOutput = {
  content: string;
  conceptIds: string[];
  sourceRefIds: string[];
};

/**
 * Check which resources are available for hint generation
 */
export function checkAvailableResources(learnerId: string): AvailableResources {
  // SQL-Engage is always available (bundled CSV)
  const sqlEngage = true;
  
  // Check if learner has textbook content
  const textbookUnits = storage.getTextbook(learnerId);
  const textbook = textbookUnits.length > 0;
  
  // Check LLM availability (Ollama or other provider)
  const llm = checkLLMAvailability();
  
  // Check PDF index
  const pdfIndex = checkPDFIndexAvailability();
  
  return { sqlEngage, textbook, llm, pdfIndex };
}

/**
 * Check if LLM service is available
 */
function checkLLMAvailability(): boolean {
  // Check if Ollama URL is configured and reachable
  const ollamaUrl = import.meta.env.VITE_OLLAMA_URL || 'http://localhost:11434';
  // Note: Actual check would require an async ping, this is a sync check
  // The service will handle failures gracefully
  return Boolean(ollamaUrl);
}

/**
 * Check if PDF index is available
 */
function checkPDFIndexAvailability(): boolean {
  const pdfIndex = storage.getPdfIndex();
  return pdfIndex !== null && pdfIndex.chunkCount > 0;
}

/**
 * Find relevant textbook units for the current error context
 */
function findRelevantTextbookUnits(
  learnerId: string,
  errorSubtypeId: string,
  conceptIds: string[]
): InstructionalUnit[] {
  const allUnits = storage.getTextbook(learnerId);
  
  if (allUnits.length === 0) return [];
  
  // Score each unit by relevance
  const scored = allUnits.map(unit => {
    let score = 0;
    
    // Match by concept ID
    if (unit.conceptId && conceptIds.includes(unit.conceptId)) {
      score += 3;
    }
    
    // Match by content similarity (simple keyword matching)
    const content = unit.content.toLowerCase();
    const errorKeywords = errorSubtypeId.toLowerCase().split(/[-_]/);
    for (const keyword of errorKeywords) {
      if (keyword.length > 3 && content.includes(keyword)) {
        score += 1;
      }
    }
    
    // Boost for recent units (within last 7 days)
    const ageMs = Date.now() - (unit.addedTimestamp || 0);
    if (ageMs < 7 * 24 * 60 * 60 * 1000) {
      score += 0.5;
    }
    
    return { unit, score };
  });
  
  // Sort by score and return top 3
  scored.sort((a, b) => b.score - a.score);
  return scored
    .filter(s => s.score > 0)
    .slice(0, 3)
    .map(s => s.unit);
}

/**
 * Generate fallback hint from SQL-Engage CSV only
 */
function generateSqlEngageFallbackHint(
  errorSubtypeId: string,
  rung: GuidanceRung
): EnhancedHint {
  const canonicalSubtype = canonicalizeSqlEngageSubtype(errorSubtypeId);
  const records = getSqlEngageRowsBySubtype(canonicalSubtype);
  
  // Get hint text based on rung
  let content: string;
  
  if (records.length > 0) {
    // Use progressive hint from SQL-Engage
    const record = records[0];
    content = getProgressiveSqlEngageHintText(canonicalSubtype, rung, record);
  } else {
    // Ultimate fallback: generic hint based on rung
    content = getGenericFallbackHint(rung, errorSubtypeId);
  }
  
  return {
    content,
    rung,
    sources: {
      sqlEngage: true,
      textbook: false,
      llm: false,
      pdfPassages: false
    },
    conceptIds: [],
    llmGenerated: false,
    confidence: 0.5 // Medium confidence for CSV-only hints
  };
}

/**
 * Get generic fallback hint when no SQL-Engage record exists
 */
function getGenericFallbackHint(rung: GuidanceRung, errorSubtypeId: string): string {
  const definitions = RUNG_DEFINITIONS[rung];
  
  if (rung === 1) {
    return `Check your ${errorSubtypeId.replace(/-/g, ' ')}. ${definitions.examples[0] || 'Review the syntax carefully.'}`;
  }
  
  if (rung === 2) {
    return `This error relates to ${errorSubtypeId.replace(/-/g, ' ')}. ` +
           `Make sure you understand the concept before proceeding. ` +
           `Refer to your course materials for examples.`;
  }
  
  // Rung 3
  return `## Summary\n\n` +
         `This problem involves ${errorSubtypeId.replace(/-/g, ' ')}.\n\n` +
         `## Common Mistakes\n\n` +
         `- Syntax errors\n` +
         `- Missing clauses\n\n` +
         `## Key Takeaway\n\n` +
         `Practice makes perfect!`;
}

/**
 * Build enhanced retrieval bundle with textbook content
 */
function buildEnhancedRetrievalBundle(
  options: HintGenerationOptions,
  resources: AvailableResources
): RetrievalBundle & { textbookUnits?: InstructionalUnit[] } {
  const { learnerId, problemId, errorSubtypeId, recentInteractions } = options;
  
  // Start with standard retrieval bundle
  const problem = getProblemById(problemId);
  const baseBundle = buildRetrievalBundle({
    learnerId,
    problem,
    interactions: recentInteractions,
    lastErrorSubtypeId: errorSubtypeId
  });
  
  // Add textbook units if available
  let textbookUnits: InstructionalUnit[] | undefined;
  if (resources.textbook && errorSubtypeId) {
    const conceptIds = baseBundle.conceptCandidates.map(c => c.id);
    textbookUnits = findRelevantTextbookUnits(learnerId, errorSubtypeId, conceptIds);
  }
  
  return {
    ...baseBundle,
    textbookUnits
  };
}

/**
 * Generate hint using available resources
 * 
 * DECISION MATRIX:
 * - LLM available + Textbook available: Full LLM with textbook context
 * - LLM available + No Textbook: LLM with SQL-Engage + PDF only
 * - No LLM + Textbook available: Enhanced SQL-Engage with textbook references
 * - No LLM + No Textbook: SQL-Engage CSV only (fallback)
 */
export async function generateEnhancedHint(
  options: HintGenerationOptions
): Promise<EnhancedHint> {
  const { learnerId, rung, errorSubtypeId, forceLLM } = options;
  
  // Check available resources
  const resources = checkAvailableResources(learnerId);
  
  // Build enhanced retrieval bundle
  const retrievalBundle = buildEnhancedRetrievalBundle(options, resources);
  
  // Decision: Can we use LLM?
  // For now, allow LLM for all rungs if forceLLM is true or for rung 2+
  // In the future, we could enable LLM for L1 too for consistency
  const canUseLLM = resources.llm && (forceLLM || rung >= 1);
  
  console.log('[EnhancedHint] Decision check:', { 
    rung, 
    forceLLM, 
    llmAvailable: resources.llm, 
    canUseLLM,
    hasTextbookContent: retrievalBundle.textbookUnits?.length > 0 
  });
  
  // Decision: Do we have textbook content?
  const hasTextbookContent = retrievalBundle.textbookUnits && 
                             retrievalBundle.textbookUnits.length > 0;
  
  // CASE 1: LLM available → Generate AI-powered hint
  if (canUseLLM) {
    console.log('[EnhancedHint] Taking CASE 1: LLM-enhanced hint');
    return generateLLMEnhancedHint(options, retrievalBundle, resources);
  }
  
  // CASE 2: No LLM but Textbook available → Enhanced SQL-Engage with textbook refs
  if (hasTextbookContent && errorSubtypeId) {
    console.log('[EnhancedHint] Taking CASE 2: Textbook-enhanced hint');
    return generateTextbookEnhancedHint(options, retrievalBundle, resources);
  }
  
  // CASE 3: Neither LLM nor Textbook → SQL-Engage CSV fallback
  if (errorSubtypeId) {
    console.log('[EnhancedHint] Taking CASE 3: SQL-Engage fallback');
    return generateSqlEngageFallbackHint(errorSubtypeId, rung);
  }
  
  // Ultimate fallback
  return {
    content: 'Review your SQL syntax and try again.',
    rung,
    sources: {
      sqlEngage: false,
      textbook: false,
      llm: false,
      pdfPassages: false
    },
    conceptIds: [],
    llmGenerated: false,
    confidence: 0.3
  };
}

/**
 * Save generated hint to My Textbook for future reference
 * Organized by problem for easy lookup
 */
export async function saveHintToTextbook(
  learnerId: string,
  problemId: string,
  rung: 1 | 2 | 3,
  hintContent: string,
  errorSubtype: string,
  conceptIds: string[],
  sourceRefIds: string[]
): Promise<void> {
  // Import storage dynamically to avoid circular deps
  const { storage } = await import('./storage');
  const { createEventId } = await import('./event-id');
  
  // Build a descriptive title based on rung and error
  const rungLabels = { 1: 'Quick Hint', 2: 'Guidance', 3: 'Detailed Help' };
  const title = `${rungLabels[rung]}: ${errorSubtype}`;
  
  // Create the instructional unit
  const unit: InstructionalUnit = {
    id: createEventId('hint'),
    type: 'hint',
    conceptId: conceptIds[0] || 'general',
    conceptIds: conceptIds.length > 0 ? conceptIds : ['general'],
    title,
    content: hintContent,
    contentFormat: 'markdown',
    prerequisites: [],
    addedTimestamp: Date.now(),
    sourceInteractionIds: [],
    sourceRefIds: sourceRefIds,
    lastErrorSubtypeId: errorSubtype,
    problemId, // Store which problem this hint belongs to
    provenance: {
      templateId: `adaptive-hint-rung-${rung}`,
      modelId: 'llm-local',
      generationParams: { rung, errorSubtype }
    }
  };
  
  // Save to textbook - use saveTextbookUnitV2 for deduplication
  const result = storage.saveTextbookUnitV2(
    learnerId,
    {
      type: 'hint',
      conceptId: unit.conceptId,
      conceptIds: unit.conceptIds,
      title: unit.title,
      content: unit.content,
      contentFormat: 'markdown',
      sourceInteractionIds: unit.sourceInteractionIds,
      sourceRefIds: unit.sourceRefIds,
      lastErrorSubtypeId: errorSubtype,
      problemId,
      provenance: unit.provenance
    },
    problemId // Pass problemId for organization
  );
  
  if (result.success) {
    console.log(`[HintSave] Saved ${rungLabels[rung]} to textbook for problem ${problemId}`);
  }
}

/**
 * Generate adaptive hint with pedagogical progression
 * 
 * This function creates progressively more helpful hints following a strict
 * pedagogical ladder that never gives away the answer.
 * 
 * Pedagogical Progression:
 * - Rung 1 (Subtle Nudge): Max 100 chars, vague direction, NO code
 * - Rung 2 (Guiding Question): Max 250 chars, leading questions, cites sources
 * - Rung 3 (Explicit Direction): Max 500 chars, clear explanation, partial patterns only
 * 
 * @param context - Context for hint generation including rung, error, problem, previous hints
 * @param llmCall - Function to call LLM with a prompt
 * @returns Promise resolving to parsed hint output
 */
export async function generateAdaptiveHint(
  context: AdaptiveHintContext,
  llmCall: (prompt: string) => Promise<string>
): Promise<AdaptiveHintOutput> {
  const { rung, errorSubtype, problem, previousHints, textbookUnits, pdfPassages } = context;
  
  // Build rung-specific prompt
  const prompt = buildAdaptivePrompt(context);
  
  try {
    console.log(`[AdaptiveHint] Generating rung ${rung} hint for ${errorSubtype}...`);
    
    // Call LLM with the adaptive prompt
    const rawOutput = await llmCall(prompt);
    
    // Debug log raw output for L3 (which seems to have issues)
    if (rung === 3) {
      console.log(`[AdaptiveHint] L3 Raw output (${rawOutput.length} chars):`, rawOutput.slice(0, 200));
    }
    
    // Parse and validate the output
    const parsed = parseAdaptiveOutput(rawOutput, rung);
    
    console.log(`[AdaptiveHint] Generated hint (${parsed.content.length} chars):`, parsed.content.slice(0, 50) + '...');
    
    // Extra debug for empty L3 hints
    if (rung === 3 && !parsed.content.trim()) {
      console.warn('[AdaptiveHint] L3 hint content is empty after parsing!');
    }
    
    return parsed;
  } catch (error) {
    console.error('[AdaptiveHint] Generation failed:', error);
    throw error;
  }
}

/**
 * Build adaptive prompt based on rung level
 * Each rung has strict pedagogical constraints
 */
function buildAdaptivePrompt(context: AdaptiveHintContext): string {
  const { rung, errorSubtype, problem, previousHints, textbookUnits, pdfPassages, sqlEngageRecords } = context;
  
  // Common context building
  const problemContext = `
PROBLEM: ${problem.title}
DESCRIPTION: ${problem.description}
SCHEMA: ${problem.schema.slice(0, 200)}...`;

  const previousHintsContext = previousHints.length > 0
    ? `\nPREVIOUS HINTS GIVEN:\n${previousHints.map((h, i) => `${i + 1}. ${h}`).join('\n')}`
    : '\nNo previous hints given.';

  const textbookContext = textbookUnits.length > 0
    ? `\nRELEVANT TEXTBOOK UNITS:\n${textbookUnits.map(u => `- "${u.title}": ${u.content.slice(0, 100)}...`).join('\n')}`
    : '\nNo textbook units available.';

  const pdfContext = pdfPassages.length > 0
    ? `\nRELEVANT PDF PASSAGES:\n${pdfPassages.map((p, i) => `[${p.docId} p.${p.page}]: ${p.snippet?.slice(0, 80) || '...'}...`).join('\n')}`
    : '\nNo PDF passages available.';

  const sqlEngageContext = sqlEngageRecords.length > 0
    ? `\nSQL-ENGAGE REFERENCE:\nError Type: ${sqlEngageRecords[0].error_subtype}\nGuidance: ${sqlEngageRecords[0].feedback_target}`
    : '';

  // Rung-specific prompts with strict pedagogical constraints
  if (rung === 1) {
    return `You are a SQL tutor providing SUBTLE NUDGES. NEVER give the answer or solution.

## ABSOLUTE PROHIBITIONS - NEVER DO THESE:
- NEVER write SQL code like "SELECT * FROM..." or any working query
- NEVER say "Use SELECT" or "Write WHERE" or any specific syntax
- NEVER give the solution even partially
- NEVER write "To fix this..." followed by code
- NEVER show a complete or partial query that works

## STRICT CONSTRAINTS FOR RUNG 1 (SUBTLE NUDGE):
- MAXIMUM 100 characters (be extremely brief)
- NO SQL keywords (SELECT, FROM, WHERE, JOIN, etc.)
- NO table names or column names as solutions
- NO code examples of any kind
- Use vague directional language ONLY: "Think about...", "Consider..."
- Point to what concept to review, NOT how to write it

## EXAMPLES OF GOOD RUNG 1 HINTS:
- "Think about what piece is missing from your query structure."
- "Consider which part tells the database where to look."
- "What determines which rows appear in your results?"

## EXAMPLES OF BAD HINTS (NEVER DO):
- "Use SELECT * FROM users" (gives solution)
- "Add a WHERE clause" (gives specific syntax)
- "Write: SELECT name FROM table" (shows code)

## FORMAT REQUIREMENTS:
Respond with ONLY the hint text (max 100 chars), then on new lines:
conceptIds: ["concept-id-1"]

${problemContext}
ERROR TYPE: ${errorSubtype}
${previousHintsContext}
${textbookContext}${pdfContext}${sqlEngageContext}

Generate a SUBTLE NUDGE (max 100 chars, absolutely NO code, NO SQL keywords):`;
  }

  if (rung === 2) {
    return `You are a SQL tutor providing GUIDING QUESTIONS. NEVER give the answer or working code.

## ABSOLUTE PROHIBITIONS - NEVER DO THESE:
- NEVER write SQL code like "SELECT * FROM..." or any working query
- NEVER say "Use SELECT" or "Write WHERE" or any specific syntax
- NEVER give the solution even partially
- NEVER show example code that solves the problem
- NEVER write "For example: SELECT..." followed by working SQL

## STRICT CONSTRAINTS FOR RUNG 2 (GUIDING QUESTION):
- MAXIMUM 250 characters
- Ask QUESTIONS only, not statements with solutions
- Reference textbook/PDF with citations like "(see your notes)"
- NO SQL code examples
- NO working queries even as "examples"
- Guide the learner to think, not to copy

## EXAMPLES OF GOOD RUNG 2 HINTS:
- "Which part of your query specifies what data to retrieve? Check your notes (p.12)."
- "What information is missing about where the data comes from?"
- "How would you narrow down which rows to show? See your notes on filtering."

## EXAMPLES OF BAD HINTS (NEVER DO):
- "Use SELECT * FROM users WHERE..." (gives solution)
- "Try: SELECT name FROM users" (shows working code)
- "Add WHERE age > 20" (gives specific syntax)

## FORMAT REQUIREMENTS:
Respond with the guiding question (max 250 chars), then on new lines:
conceptIds: ["concept-id-1", "concept-id-2"]
sourceRefIds: ["doc:chunk:page"]

${problemContext}
ERROR TYPE: ${errorSubtype}
${previousHintsContext}
${textbookContext}${pdfContext}${sqlEngageContext}

Generate a GUIDING QUESTION (max 250 chars, NO code, NO solutions):`;
  }

  // Rung 3
  return `You are a SQL tutor providing EXPLICIT DIRECTION. Help them understand but NEVER give working code.

## ABSOLUTE PROHIBITIONS - NEVER DO THESE:
- NEVER write a complete working SQL query
- NEVER write "Example: SELECT * FROM..." with real code
- NEVER give copy-paste solutions
- NEVER show "Solution: " followed by working SQL
- NEVER write actual SQL that would run correctly

## STRICT CONSTRAINTS FOR RUNG 3 (EXPLICIT DIRECTION):
- MAXIMUM 500 characters
- Explain CONCEPTS only, not syntax
- Use blanks like "SELECT ___ FROM ___" (underscores for blanks)
- Cite sources from textbook/PDF
- NO working code examples
- Learner must figure out the actual syntax themselves

## EXAMPLES OF GOOD RUNG 3 HINTS:
- "You need two pieces: what to retrieve and where it comes from. Structure: SELECT ___ FROM ___. The blanks are for you to fill in. (p.12)"
- "First identify the table, then what columns you need. Use your notes on SELECT structure."

## EXAMPLES OF BAD HINTS (NEVER DO):
- "SELECT * FROM users" (complete solution)
- "Example: SELECT name FROM users WHERE..." (working example)
- "Solution: SELECT * FROM table WHERE condition" (gives answer)
- "Use SELECT * to get all columns" (specific instruction)"
- "To filter results, use WHERE with a condition. Pattern: SELECT columns FROM table WHERE condition. See your notes on filtering data (p.45)."
- "Joining tables requires: SELECT ___ FROM table1 JOIN table2 ON ___. The ON clause specifies how tables connect. Check your notes on JOIN conditions."

## FORMAT REQUIREMENTS:
Respond with the explicit direction (max 500 chars), then on new lines:
conceptIds: ["concept-id-1", "concept-id-2"]
sourceRefIds: ["doc:chunk:page", "doc:chunk:page2"]

${problemContext}
ERROR TYPE: ${errorSubtype}
${previousHintsContext}
${textbookContext}${pdfContext}${sqlEngageContext}

Generate EXPLICIT DIRECTION (max 500 chars, use ___ for blanks, cite sources, NO complete solutions):`;
}

/**
 * Parse LLM output for adaptive hints
 * Validates against rung-specific constraints
 */
function parseAdaptiveOutput(rawOutput: string, rung: 1 | 2 | 3): AdaptiveHintOutput {
  let content = rawOutput;
  const conceptIds: string[] = [];
  const sourceRefIds: string[] = [];

  // Debug logging for L1 hint issues
  if (rung === 1 && process.env.NODE_ENV !== 'production') {
    console.log('[AdaptiveHint] Raw LLM output:', rawOutput.slice(0, 500));
  }

  // Try to parse JSON responses (for backward compatibility with test mocks)
  // Some LLM responses may return JSON with fields like content, content_markdown, etc.
  try {
    const trimmed = rawOutput.trim();
    if ((trimmed.startsWith('{') && trimmed.endsWith('}')) ||
        (trimmed.startsWith('"{') && trimmed.endsWith('}"'))) {
      // Handle double-encoded JSON
      const jsonStr = trimmed.startsWith('"') ? JSON.parse(trimmed) : trimmed;
      const parsed = JSON.parse(jsonStr);
      
      // Extract content from various possible fields (priority order)
      if (parsed.content && typeof parsed.content === 'string') {
        content = parsed.content;
      } else if (parsed.content_markdown && typeof parsed.content_markdown === 'string') {
        content = parsed.content_markdown;
      } else if (parsed.contentmarkdown && typeof parsed.contentmarkdown === 'string') {
        content = parsed.contentmarkdown;
      } else if (parsed.text && typeof parsed.text === 'string') {
        content = parsed.text;
      } else if (parsed.response && typeof parsed.response === 'string') {
        content = parsed.response;
      }
      
      // Extract conceptIds from JSON if present
      if (parsed.conceptIds && Array.isArray(parsed.conceptIds)) {
        conceptIds.push(...parsed.conceptIds.filter((id: unknown) => typeof id === 'string'));
      }
      if (parsed.concept_ids && Array.isArray(parsed.concept_ids)) {
        conceptIds.push(...parsed.concept_ids.filter((id: unknown) => typeof id === 'string'));
      }
      
      // Extract sourceRefIds from JSON if present
      if (parsed.sourceRefIds && Array.isArray(parsed.sourceRefIds)) {
        sourceRefIds.push(...parsed.sourceRefIds.filter((id: unknown) => typeof id === 'string'));
      }
      if (parsed.source_ids && Array.isArray(parsed.source_ids)) {
        sourceRefIds.push(...parsed.source_ids.filter((id: unknown) => typeof id === 'string'));
      }
      
      console.log('[AdaptiveHint] Parsed JSON response, extracted content:', content.slice(0, 100));
    }
  } catch {
    // Not valid JSON or parsing failed, treat as plain text
    // Continue with normal parsing
  }

  // Extract conceptIds (from text format as fallback)
  const conceptIdsMatch = content.match(/conceptIds:\s*\[([^\]]*)\]/i);
  if (conceptIdsMatch) {
    content = content.replace(conceptIdsMatch[0], '').trim();
    const ids = conceptIdsMatch[1]
      .split(',')
      .map(id => id.trim().replace(/["']/g, ''))
      .filter(Boolean);
    conceptIds.push(...ids);
  }

  // Extract sourceRefIds (from text format as fallback)
  const sourceRefIdsMatch = content.match(/sourceRefIds:\s*\[([^\]]*)\]/i);
  if (sourceRefIdsMatch) {
    content = content.replace(sourceRefIdsMatch[0], '').trim();
    const ids = sourceRefIdsMatch[1]
      .split(',')
      .map(id => id.trim().replace(/["']/g, ''))
      .filter(Boolean);
    sourceRefIds.push(...ids);
  }

  // Clean up any echoed prompt content
  // Use multiline (^) matching to only remove lines that START with these keywords
  const promptEchoPatterns = [
    /^PROBLEM:.*$/gim,
    /^DESCRIPTION:.*$/gim,
    /^SCHEMA:.*$/gim,
    /^ERROR TYPE:.*$/gim,
    /^PREVIOUS HINTS GIVEN:.*$/gim,
    /^RELEVANT TEXTBOOK UNITS:.*$/gim,
    /^RELEVANT PDF PASSAGES:.*$/gim,
    /^SQL-ENGAGE REFERENCE:.*$/gim,
    /^Generate (?:a )?(?:SUBTLE NUDGE|GUIDING QUESTION|EXPLICIT DIRECTION).*$/gim,
    // Additional artifacts from LLM output
    /^##?\s*GENERATED HINT:?.*$/gim,
    /^##?\s*HINT:?.*$/gim,
    /^##?\s*RUNG \d HINT:?.*$/gim,
    /^##?\s*RESPONSE:?.*$/gim,
    /^Here is (?:a |the )?(?:hint|response|answer):?.*$/gim,
    /^\*\*Hint:\*\s*/gi,
    /^\*\*Response:\*\s*/gi,
  ];

  for (const pattern of promptEchoPatterns) {
    content = content.replace(pattern, '');
  }

  // Clean up multiple newlines
  content = content.replace(/\n{3,}/g, '\n\n').trim();

  // Debug logging after cleanup (for L1 and L3 rungs which have had issues)
  if ((rung === 1 || rung === 3) && process.env.NODE_ENV !== 'production') {
    console.log(`[AdaptiveHint] L${rung} content after cleanup:`, content.slice(0, 200) || '(empty)');
  }

  // Enforce length constraints based on rung
  const maxLengths = { 1: 100, 2: 250, 3: 500 };
  const maxLength = maxLengths[rung];
  
  if (content.length > maxLength) {
    console.warn(`[AdaptiveHint] Hint exceeded max length (${content.length} > ${maxLength}), truncating...`);
    content = content.slice(0, maxLength - 3) + '...';
  }
  
  // Ensure content is never empty - fallback to generic hint if LLM returns empty
  if (!content.trim()) {
    console.warn(`[AdaptiveHint] Empty content for rung ${rung}, using fallback`);
    content = getGenericFallbackHint(rung, 'incomplete query');
  }

  return { content: content.trim(), conceptIds, sourceRefIds };
}

/**
 * Generate LLM-enhanced hint with adaptive pedagogical progression
 */
async function generateLLMEnhancedHint(
  options: HintGenerationOptions,
  retrievalBundle: RetrievalBundle & { textbookUnits?: InstructionalUnit[] },
  resources: AvailableResources
): Promise<EnhancedHint> {
  const { rung, errorSubtypeId } = options;
  
  if (!errorSubtypeId) {
    throw new Error('Cannot generate LLM hint without errorSubtypeId');
  }

  // Import LLM client dynamically to avoid circular dependencies
  const { generateWithOllama } = await import('./llm-client');
  
  try {
    console.log('[EnhancedHint] Generating adaptive LLM hint for rung', rung, '...');
    
    // Build adaptive hint context
    const problem = getProblemById(options.problemId);
    if (!problem) {
      throw new Error(`Problem not found: ${options.problemId}`);
    }

    // Get previous hints from recent interactions
    const previousHints = options.recentInteractions
      .filter(i => i.eventType === 'hint_view' && i.hintText)
      .map(i => i.hintText!)
      .slice(-3); // Last 3 hints

    // Get SQL-Engage records for context
    const canonicalSubtype = canonicalizeSqlEngageSubtype(errorSubtypeId);
    const sqlEngageRecords = getSqlEngageRowsBySubtype(canonicalSubtype);

    // Build the adaptive context
    const adaptiveContext: AdaptiveHintContext = {
      rung,
      errorSubtype: errorSubtypeId,
      problem,
      previousHints,
      textbookUnits: retrievalBundle.textbookUnits || [],
      pdfPassages: retrievalBundle.pdfPassages.map(p => ({
        docId: p.docId,
        chunkId: p.chunkId,
        page: p.page,
        score: 0,
        snippet: p.text
      })),
      sqlEngageRecords
    };

    // Create LLM call function
    const llmCall = async (prompt: string): Promise<string> => {
      const result = await generateWithOllama(prompt);
      return result.text;
    };

    // Generate using adaptive hint algorithm
    const hintOutput = await generateAdaptiveHint(adaptiveContext, llmCall);
    
    console.log('[EnhancedHint] Adaptive hint generated:', hintOutput.content.slice(0, 50) + '...');
    
    // Save hint to textbook for future reference
    try {
      await saveHintToTextbook(
        options.learnerId,
        options.problemId,
        rung,
        hintOutput.content,
        errorSubtypeId,
        hintOutput.conceptIds,
        hintOutput.sourceRefIds
      );
    } catch (saveError) {
      console.warn('[EnhancedHint] Failed to save hint to textbook:', saveError);
    }
    
    // Return LLM-generated hint
    return {
      content: hintOutput.content,
      rung,
      sources: {
        sqlEngage: resources.sqlEngage,
        textbook: Boolean(retrievalBundle.textbookUnits?.length),
        llm: true,
        pdfPassages: resources.pdfIndex
      },
      conceptIds: hintOutput.conceptIds,
      sourceRefIds: hintOutput.sourceRefIds,
      textbookUnits: retrievalBundle.textbookUnits,
      llmGenerated: true,
      confidence: 0.9 // High confidence for LLM-generated
    };
    
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'LLM service unavailable';
    console.warn('[EnhancedHint] Adaptive LLM generation failed:', errorMessage);
    
    // Fallback to SQL-Engage if adaptive hint generation fails
    const fallbackHint = generateSqlEngageFallbackHint(errorSubtypeId, rung);
    
    // Mark that LLM was attempted but failed (for UI feedback)
    return {
      ...fallbackHint,
      llmFailed: true,
      llmErrorMessage: errorMessage
    };
  }
}

/**
 * Generate hint enhanced with textbook references (no LLM)
 */
function generateTextbookEnhancedHint(
  options: HintGenerationOptions,
  retrievalBundle: RetrievalBundle & { textbookUnits?: InstructionalUnit[] },
  resources: AvailableResources
): EnhancedHint {
  const { rung, errorSubtypeId } = options;
  const { textbookUnits = [] } = retrievalBundle;
  
  if (!errorSubtypeId) {
    throw new Error('Cannot generate hint without errorSubtypeId');
  }
  
  // Get base hint from SQL-Engage
  const baseHint = generateSqlEngageFallbackHint(errorSubtypeId, rung);
  
  // Enhance with textbook references
  let enhancedContent = baseHint.content;
  
  if (textbookUnits.length > 0 && rung >= 2) {
    // Add "See also" references to relevant textbook units
    const references = textbookUnits
      .slice(0, 2)
      .map(unit => `• "${unit.title}" (in your Textbook)`)
      .join('\n');
    
    enhancedContent += `\n\n**Related from your Textbook:**\n${references}`;
  }
  
  return {
    ...baseHint,
    content: enhancedContent,
    sources: {
      ...baseHint.sources,
      textbook: true
    },
    textbookUnits,
    confidence: 0.7 // Higher confidence with textbook refs
  };
}

/**
 * Get hint generation strategy description for UI
 */
export function getHintStrategyDescription(resources: AvailableResources): string {
  if (resources.llm && resources.textbook) {
    return 'AI-powered hints with your Textbook and course materials';
  }
  if (resources.llm) {
    return 'AI-powered hints with course materials';
  }
  if (resources.textbook) {
    return 'Hints from SQL-Engage dataset + your Textbook references';
  }
  return 'Hints from SQL-Engage dataset';
}

/**
 * Preload hint for upcoming error subtype (predictive loading)
 */
export async function preloadHintContext(
  learnerId: string,
  errorSubtypeId: string
): Promise<void> {
  const resources = checkAvailableResources(learnerId);
  
  // Pre-fetch relevant textbook units
  if (resources.textbook) {
    findRelevantTextbookUnits(learnerId, errorSubtypeId, []);
  }
  
  // Could also preload PDF passages here
}

// Export version for tracking
export const ENHANCED_HINT_SERVICE_VERSION = 'enhanced-hint-v2.0.0-adaptive';
